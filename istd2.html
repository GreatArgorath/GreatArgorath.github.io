<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Authoritarian Type</title>
  <style>
    html,body { height: 100%; margin: 0; }
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: #000; color: #fff; }
    .video-bg--base {
      position: fixed;
      top: 50%;
      left: 50%;
      width: auto;
      height: auto;
      max-width: 100%;
      min-height: 100%;
      transform: translate(-50%, -50%);
      object-fit: cover;
      z-index: -1;
      filter: invert(1);
    }
    .video-overlay {
      position: fixed;
      top: 50%;
      left: 50%;
      width: auto;
      height: auto;
      max-width: 70%;
      max-height: 70%;
      transform: translate(-50%, -50%);
      object-fit: cover;
      z-index: 0; /* sits above base video but below content */
      pointer-events: none;
    }
    .content {
      position: relative;
      z-index: 1;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 1rem;
    }
    .hello {
      font-size: clamp(1.5rem, 6vw, 4rem);
      text-shadow: 0 2px 12px rgba(0,0,0,0.6);
    }
  </style>
</head>
<body>
  <!-- Base background video -->
  <video class="video-bg--base" autoplay muted loop playsinline poster="videos/poster.jpg" aria-hidden="true">
    <source src="https://file.garden/aKXmtMu4gl9vV3YB/paperbackground.mp4" type="video/mp4">
    <!-- Fallback: still image -->
  </video>

  <!-- Overlay WebM with alpha (transparency) -->
  <video class="video-overlay" autoplay muted loop playsinline preload="auto" aria-hidden="true">
    <source src="https://file.garden/aKXmtMu4gl9vV3YB/authoritariantypefutura.webm" type="video/webm">
    <!-- If the browser doesn't support WebM with alpha, this will simply be ignored -->
  </video>



  <script>
    // keep videos tightly in sync (base is master)
    (function(){
      const base = document.querySelector('.video-bg--base');
      const overlay = document.querySelector('.video-overlay');
      if (!base || !overlay) return;

      const TARGET_RATE = 0.5;      // desired playback rate for both
      const SYNC_THRESHOLD = 0.05;  // seconds of allowed drift before jump
      let rafId = null;

      function safeSetCurrentTime(video, t) {
        try { if (isFinite(t) && video.readyState >= 1) video.currentTime = t; } catch (e) { /* ignore */ }
      }

      function setRates() {
        try { base.playbackRate = TARGET_RATE; } catch {}
        try { overlay.playbackRate = TARGET_RATE; } catch {}
      }

      function initSyncIfReady() {
        if (base.readyState >= 1 && overlay.readyState >= 1) {
          safeSetCurrentTime(overlay, base.currentTime || 0);
          overlay.playbackRate = base.playbackRate;
        }
      }

      function correctDrift() {
        if (!isFinite(base.currentTime) || !isFinite(overlay.currentTime)) return;
        const diff = base.currentTime - overlay.currentTime;
        if (Math.abs(diff) > SYNC_THRESHOLD) {
          // jump overlay to match base
          safeSetCurrentTime(overlay, base.currentTime);
        }
      }

      function syncLoop() {
        correctDrift();
        rafId = requestAnimationFrame(syncLoop);
      }

      function startLoop() { if (!rafId) syncLoop(); }
      function stopLoop() { if (rafId) { cancelAnimationFrame(rafId); rafId = null; } }

      // Mirror play/pause/seeking/rate changes from base -> overlay
      base.addEventListener('play', () => { overlay.play().catch(()=>{}); startLoop(); });
      base.addEventListener('pause', () => { overlay.pause(); stopLoop(); });
      base.addEventListener('seeking', () => { safeSetCurrentTime(overlay, base.currentTime); });
      base.addEventListener('ratechange', () => { overlay.playbackRate = base.playbackRate; });

      // If overlay is interacted with, mirror back to base (keeps either as master)
      overlay.addEventListener('seeking', () => { safeSetCurrentTime(base, overlay.currentTime); });
      overlay.addEventListener('ratechange', () => { base.playbackRate = overlay.playbackRate; });

      base.addEventListener('loadedmetadata', initSyncIfReady);
      overlay.addEventListener('loadedmetadata', initSyncIfReady);

      // initial setup
      setRates();
      initSyncIfReady();
      Promise.allSettled([base.play(), overlay.play()]).catch(()=>{});

      // periodic fallback
      const intervalId = setInterval(() => {
        if (document.hidden) return;
        correctDrift();
      }, 500);

      window.addEventListener('unload', () => {
        stopLoop();
        clearInterval(intervalId);
      });
    })();
  </script>
</body>
</html>